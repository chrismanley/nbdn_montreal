using System;

namespace nothinbutdotnetprep.infrastructure.searching
{
    public class Where<ItemToFilter>
    {
<<<<<<< HEAD
        static public Func<ItemToFilter, Property> has_a<Property>(Func<ItemToFilter, Property> property_accessor)
        {
            return property_accessor;
=======
        static public CriteriaFactory<ItemToFilter, Property> has_a<Property>(Func<ItemToFilter, Property> property_accessor)
        {
            return new DefaultCriteriaFactory<ItemToFilter, Property>(property_accessor);
        }

        static public ComparableCriteriaFactory<ItemToFilter, Property> has_an<Property>(Func<ItemToFilter, Property> property_accessor) where Property : IComparable<Property>
        {
            return new ComparableCriteriaFactory<ItemToFilter, Property>(property_accessor);
>>>>>>> 4c1ded3e7204da82c2163791554733df73050fac
        }
    }

    public static class FuncExtensions
    {
        public static Criteria<ItemToFilter> equal_to<ItemToFilter, Property>(this Func<ItemToFilter, Property> func, Property property) 
        {
            return new AnonymousCriteria<ItemToFilter>(itemToFilter => func(itemToFilter).Equals(property));
        }

        //public static Criteria<ItemToFilter> equal_to_any<ItemToFilter, Property>(this Func<ItemToFilter, Property> func, Property property)
        //{
        //    return new AnonymousCriteria<ItemToFilter>(itemToFilter => func(itemToFilter).Equals(property));
        //}
    }

    class AnonymousCriteria<T> : Criteria<T>
    {
        readonly Predicate<T> predicate;

        public AnonymousCriteria(Predicate<T> predicate)
        {
            this.predicate = predicate;
        }

        public bool is_satisfied_by(T item)
        {
            return predicate(item);
        }
    }
}